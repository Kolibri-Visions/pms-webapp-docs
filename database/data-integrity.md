# PMS-Core Data Integrity Documentation

## Overview

This document describes the data integrity constraints, validation rules, and business rules implemented in the PMS-Core database schema to ensure data consistency and prevent invalid states.

---

## 1. Primary Key Constraints

All tables use UUID primary keys generated by `gen_random_uuid()`:

```sql
id UUID PRIMARY KEY DEFAULT gen_random_uuid()
```

**Rationale:**
- No sequential ID guessing (security)
- Safe for distributed systems
- Client-side ID generation possible
- No integer overflow concerns

---

## 2. Foreign Key Constraints

### Cascade Behaviors

| Relationship | ON DELETE | ON UPDATE | Rationale |
|-------------|-----------|-----------|-----------|
| user_tenant_roles -> auth.users | CASCADE | CASCADE | User deletion removes all roles |
| user_tenant_roles -> tenants | CASCADE | CASCADE | Tenant deletion removes all roles |
| properties -> tenants | CASCADE | CASCADE | Tenant deletion removes properties |
| guests -> tenants | CASCADE | CASCADE | Tenant deletion removes guests |
| guests -> auth.users | SET NULL | CASCADE | User deletion preserves guest data |
| bookings -> properties | RESTRICT | CASCADE | Cannot delete property with bookings |
| bookings -> guests | RESTRICT | CASCADE | Cannot delete guest with bookings |
| invoices -> bookings | SET NULL | CASCADE | Booking deletion preserves invoice |
| reviews -> guests | RESTRICT | CASCADE | Cannot delete guest with reviews |

### Key Foreign Key Definitions

```sql
-- Guests: Optional auth linkage
guests.auth_user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL

-- Bookings: Protect property and guest references
bookings.property_id UUID NOT NULL REFERENCES properties(id) ON DELETE RESTRICT
bookings.guest_id UUID NOT NULL REFERENCES guests(id) ON DELETE RESTRICT

-- Calendar: Booking reference cleanup
calendar_availability.booking_id UUID REFERENCES bookings(id) ON DELETE SET NULL
```

---

## 3. Check Constraints

### Enum-Style Constraints

All status and type fields use CHECK constraints to enforce valid values:

```sql
-- Tenant subscription tiers
subscription_tier TEXT NOT NULL DEFAULT 'free' CHECK (
    subscription_tier IN ('free', 'starter', 'professional', 'enterprise')
)

-- Booking status lifecycle
status TEXT NOT NULL DEFAULT 'inquiry' CHECK (
    status IN (
        'inquiry', 'pending', 'confirmed', 'checked_in',
        'checked_out', 'cancelled', 'declined', 'no_show'
    )
)

-- Payment status
payment_status TEXT NOT NULL DEFAULT 'pending' CHECK (
    payment_status IN (
        'pending', 'partial', 'paid', 'refunded',
        'partial_refund', 'failed', 'external'
    )
)

-- Property types
property_type TEXT NOT NULL CHECK (
    property_type IN ('apartment', 'house', 'villa', 'condo', 'room', 'studio', 'cabin', 'cottage', 'chalet')
)
```

### Numeric Constraints

```sql
-- Positive values
bedrooms INT NOT NULL CHECK (bedrooms >= 0)
bathrooms NUMERIC(3,1) NOT NULL CHECK (bathrooms >= 0)
max_guests INT NOT NULL CHECK (max_guests > 0)
num_adults INT NOT NULL DEFAULT 1 CHECK (num_adults > 0)
num_children INT NOT NULL DEFAULT 0 CHECK (num_children >= 0)

-- Stay constraints
min_stay INT NOT NULL DEFAULT 1 CHECK (min_stay >= 1)
max_stay INT DEFAULT 365 CHECK (max_stay >= 1)

-- Rating bounds
overall_rating NUMERIC(2,1) NOT NULL CHECK (overall_rating >= 1 AND overall_rating <= 5)
```

### Date Constraints

```sql
-- Booking dates must be valid
CONSTRAINT check_dates CHECK (check_out > check_in)

-- Invitation expiry
expires_at TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '7 days')
```

---

## 4. Unique Constraints

### Simple Unique Constraints

```sql
-- Tenant email
tenants.email TEXT NOT NULL UNIQUE

-- Booking reference (human-readable ID)
bookings.booking_reference TEXT NOT NULL UNIQUE

-- Invoice number
invoices.invoice_number TEXT NOT NULL UNIQUE

-- Amenity codes
amenity_definitions.code TEXT NOT NULL UNIQUE
```

### Composite Unique Constraints

```sql
-- User can only have one role per tenant
user_tenant_roles: UNIQUE(user_id, tenant_id)

-- Guest email unique per tenant (allows same guest across tenants)
guests: UNIQUE(tenant_id, email)

-- One calendar entry per property per date
calendar_availability: UNIQUE(property_id, date)

-- One channel connection per property per channel type
channel_connections: UNIQUE(property_id, channel_type)

-- One review per booking
reviews: UNIQUE(booking_id)
```

### Partial Unique Constraints

```sql
-- Channel booking ID unique only when not NULL
-- Prevents duplicate imports while allowing NULL for direct bookings
CONSTRAINT check_channel_id UNIQUE NULLS NOT DISTINCT (source, channel_booking_id)
```

---

## 5. Exclusion Constraints (Double-Booking Prevention)

The most critical constraint in the system prevents overlapping bookings:

```sql
-- Prevent overlapping bookings for the same property
CONSTRAINT no_double_bookings EXCLUDE USING gist (
    property_id WITH =,
    daterange(check_in, check_out, '[)') WITH &&
) WHERE (status NOT IN ('cancelled', 'declined', 'no_show'))
```

**Explanation:**
- Uses GiST index with btree_gist extension
- `daterange(check_in, check_out, '[)')` creates a range including check_in, excluding check_out
- `&&` operator checks for overlap
- Only active bookings are considered (cancelled/declined excluded)
- Database-level guarantee of no double bookings

**Example:**
```
Existing booking: Jan 1-5 (check_in=1, check_out=5)
Allowed: Jan 5-10 (starts exactly when previous ends)
Blocked: Jan 4-10 (overlaps on Jan 4)
Blocked: Jan 3-4 (within existing range)
```

---

## 6. NOT NULL Constraints

### Required Fields by Table

**tenants:**
- name, email, subscription_tier, subscription_status

**properties:**
- tenant_id, name, property_type, bedrooms, beds, bathrooms, max_guests
- base_price, currency, min_stay, status

**guests:**
- tenant_id, first_name, last_name, email

**bookings:**
- tenant_id, property_id, guest_id, booking_reference
- check_in, check_out, num_adults
- source, status, version
- nightly_rate, subtotal, total_price, currency, payment_status

---

## 7. Generated Columns

Computed columns that stay consistent with source data:

```sql
-- Total guests = adults + children
num_guests INT GENERATED ALWAYS AS (num_adults + num_children) STORED

-- Number of nights
num_nights INT GENERATED ALWAYS AS (check_out - check_in) STORED
```

**Benefits:**
- Always consistent (cannot be out of sync)
- Indexed for queries
- No application logic needed

---

## 8. Default Values

### Timestamps
```sql
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
```

### Status Defaults
```sql
-- Start in safe initial states
status TEXT NOT NULL DEFAULT 'draft'  -- properties
status TEXT NOT NULL DEFAULT 'inquiry'  -- bookings
payment_status TEXT NOT NULL DEFAULT 'pending'  -- bookings
```

### JSON Defaults
```sql
-- Empty arrays/objects
amenities JSONB DEFAULT '[]'::jsonb
address JSONB DEFAULT '{}'::jsonb
channel_data JSONB DEFAULT '{}'::jsonb
```

---

## 9. Business Rules (Application Layer)

Some rules require application-level enforcement:

### Booking Status Transitions

Valid transitions:
```
inquiry -> pending, declined
pending -> confirmed, cancelled, declined
confirmed -> checked_in, cancelled, no_show
checked_in -> checked_out, cancelled
checked_out -> (terminal state)
cancelled -> (terminal state)
declined -> (terminal state)
no_show -> (terminal state)
```

### Guest Account Linking

1. Guest can exist without auth account (`auth_user_id = NULL`)
2. When guest accepts invitation, `auth_user_id` is set
3. Guest can only be linked to one auth user
4. Multiple guests (different tenants) can link to same auth user

### Property Availability Logic

1. Property must be `status = 'active'` to accept bookings
2. Check `calendar_availability` for specific date blocks
3. Check `bookings` for confirmed reservations
4. Respect `min_stay` and `max_stay` rules

---

## 10. Soft Delete Pattern

Tables supporting soft delete:
- tenants
- properties
- guests

```sql
deleted_at TIMESTAMPTZ  -- NULL = not deleted

-- Queries should filter:
WHERE deleted_at IS NULL
```

**Indexes for soft delete:**
```sql
CREATE INDEX idx_properties_active ON properties(tenant_id)
    WHERE status = 'active' AND deleted_at IS NULL;
```

---

## 11. Optimistic Locking

Bookings use optimistic locking to prevent concurrent update conflicts:

```sql
version INT NOT NULL DEFAULT 1
```

**Application usage:**
```sql
UPDATE bookings
SET ..., version = version + 1
WHERE id = $1 AND version = $2
RETURNING version;
-- If no rows returned, conflict occurred
```

**Trigger:**
```sql
CREATE TRIGGER booking_version_trigger
    BEFORE UPDATE ON bookings
    FOR EACH ROW EXECUTE FUNCTION increment_booking_version();
```

---

## 12. Audit Trail Integrity

### Booking Audit Log

Every booking change is logged automatically:

```sql
CREATE TABLE booking_audit_log (
    id UUID PRIMARY KEY,
    booking_id UUID NOT NULL REFERENCES bookings(id) ON DELETE CASCADE,
    action TEXT NOT NULL,  -- 'created', 'updated', 'status_changed', etc.
    old_data JSONB,
    new_data JSONB,
    changed_fields TEXT[],
    changed_by UUID,
    changed_by_type TEXT,  -- 'user', 'guest', 'system', 'channel'
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Trigger ensures logging:**
```sql
CREATE TRIGGER booking_audit_trigger
    AFTER INSERT OR UPDATE ON bookings
    FOR EACH ROW EXECUTE FUNCTION log_booking_changes();
```

---

## 13. Referential Integrity Examples

### Scenario: Delete a Property

```sql
DELETE FROM properties WHERE id = $1;
```

**Result:** ERROR - RESTRICT violation if bookings exist

**Correct approach:**
1. Cancel all active bookings
2. Archive property (`status = 'archived'`)
3. Or use soft delete (`deleted_at = NOW()`)

### Scenario: Delete a Guest with Auth Account

```sql
-- When auth.users entry is deleted:
DELETE FROM auth.users WHERE id = $1;
```

**Result:** Guest record preserved, `auth_user_id` set to NULL

### Scenario: Delete a Booking

```sql
DELETE FROM bookings WHERE id = $1;
```

**Result:**
- booking_status_history entries deleted (CASCADE)
- booking_addons deleted (CASCADE)
- booking_audit_log entries deleted (CASCADE)
- calendar_availability.booking_id set to NULL (SET NULL)
- invoices.booking_id set to NULL (SET NULL)

---

## 14. Data Validation Checklist

When inserting/updating data, verify:

### Bookings
- [ ] check_out > check_in
- [ ] num_adults > 0
- [ ] total_price = subtotal + fees - discounts + tax
- [ ] No overlapping bookings (exclusion constraint)
- [ ] Property status = 'active'
- [ ] Property.max_guests >= num_guests

### Guests
- [ ] Email format valid (application layer)
- [ ] Phone format valid (application layer)
- [ ] Unique email per tenant

### Properties
- [ ] Valid property_type
- [ ] max_guests > 0
- [ ] base_price >= 0
- [ ] Valid address structure

### Calendar Availability
- [ ] Date not in past (for new blocks)
- [ ] price >= 0 if set
- [ ] min_stay >= 1

---

## 15. Error Handling

### Common Constraint Violations

| Error Code | Constraint | Recovery |
|------------|------------|----------|
| 23505 | unique_violation | Duplicate key - show user-friendly message |
| 23503 | foreign_key_violation | Referenced record doesn't exist |
| 23514 | check_violation | Invalid value for constraint |
| 23P01 | exclusion_violation | Double-booking attempt |

### Application Error Handling

```python
try:
    await db.execute(insert_booking_query)
except asyncpg.UniqueViolationError as e:
    if 'no_double_bookings' in str(e):
        raise BookingConflictError("Property not available for these dates")
    elif 'check_channel_id' in str(e):
        raise DuplicateBookingError("Booking already imported from channel")
except asyncpg.CheckViolationError as e:
    if 'check_dates' in str(e):
        raise ValidationError("Check-out must be after check-in")
```

---

## 16. Data Migration Safety

When modifying schema:

### Adding NOT NULL Column
```sql
-- 1. Add nullable first
ALTER TABLE bookings ADD COLUMN new_field TEXT;

-- 2. Backfill data
UPDATE bookings SET new_field = 'default_value';

-- 3. Add NOT NULL constraint
ALTER TABLE bookings ALTER COLUMN new_field SET NOT NULL;
```

### Adding Check Constraint
```sql
-- Validate existing data first
SELECT * FROM bookings WHERE status NOT IN (...valid values...);

-- Add constraint only if data is clean
ALTER TABLE bookings ADD CONSTRAINT check_status CHECK (status IN (...));
```

### Modifying Foreign Keys
```sql
-- Always test with RESTRICT first
ALTER TABLE child_table
    DROP CONSTRAINT fk_name,
    ADD CONSTRAINT fk_name
        FOREIGN KEY (parent_id)
        REFERENCES parent_table(id)
        ON DELETE RESTRICT;
```

---

## 17. Summary

The PMS-Core database implements multiple layers of data integrity:

1. **Database Level:**
   - Primary keys (UUID)
   - Foreign keys (with appropriate cascade behaviors)
   - Unique constraints (simple and composite)
   - Check constraints (enums, numerics, dates)
   - Exclusion constraints (double-booking prevention)
   - NOT NULL constraints
   - Generated columns

2. **Trigger Level:**
   - Automatic timestamps
   - Reference number generation
   - Audit logging
   - Calendar synchronization
   - Statistics updates

3. **Application Level:**
   - Status transition validation
   - Complex business rules
   - Input format validation
   - Cross-entity validation

This multi-layered approach ensures data integrity even if application bugs occur, providing a robust foundation for the PMS-Core system.
